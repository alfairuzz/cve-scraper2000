import pandas as pd
from bs4 import BeautifulSoup

def get_oracle_details(soup):
    """
    Extracts vulnerability details from Oracle's security updates page.

    Parameters:
    soup (BeautifulSoup): The parsed HTML content of the Oracle security updates page.

    Returns:
    List[pd.DataFrame]: A list of DataFrames containing structured vulnerability details.
    """
    print('Retrieving Oracle Data...')

    # Find all tables with the class 'otable-w2'
    tables = soup.find_all('table', class_='otable-w2')

    # Initialize a list to store DataFrames
    dataframe_list = []

    # Loop through each table found on the webpage
    for table in tables:
        # Extract table headers (handle multi-row headers if applicable)
        headers = []
        theads = table.find_all('thead')
        if not theads:
            continue  # Skip table if no headers are found

        for thead in theads:
            header_rows = thead.find_all('tr')
            for header_row in header_rows:
                headers.append([th.get_text(separator=" ").strip() for th in header_row.find_all('th')])

        # Flatten multi-row headers into a single list
        flat_headers = [item for sublist in headers for item in sublist]

        # Extract table data
        data = []
        tbody = table.find('tbody')
        if not tbody:
            continue  # Skip if tbody is not found

        for row in tbody.find_all('tr'):
            row_data = [td.get_text(separator=" ").strip() for td in row.find_all(['td', 'th'])]

            # Pad row data with empty strings if it's shorter than the header
            if len(row_data) < len(flat_headers):
                row_data += [''] * (len(flat_headers) - len(row_data))

            data.append(row_data)

        # Create a DataFrame with the extracted headers and data
        df = pd.DataFrame(data, columns=flat_headers)

        # Standardize column names if the table matches expected format
        expected_columns = 16
        if len(df.columns) >= expected_columns:
            custom_headers = [
                "CVE ID", "Product", "Component", "Protocol", "Remote Exploit without Authentication?",
                "Base Score", "Attack Vector", "Attack Complexity", "Privileges Required",
                "User Interaction", "Scope", "Confidentiality", "Integrity",
                "Availability", "Supported Versions Affected", "Notes", "Blank Column"
            ]

            # Adjust the DataFrame to match the number of custom headers
            df = df.iloc[:, :len(custom_headers)]
            df.columns = custom_headers[:len(df.columns)]

            # Drop the 'Blank Column' if it exists
            if "Blank Column" in df.columns:
                df = df.drop(columns=["Blank Column"])

            dataframe_list.append(df)

    return dataframe_list
