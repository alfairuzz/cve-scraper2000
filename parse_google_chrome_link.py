import re
import pandas as pd
from bs4 import BeautifulSoup

def get_google_chrome_details(soup):
    """
    Extracts vulnerability details from Google's Chrome Release blog page.

    Parameters:
    soup (BeautifulSoup): The parsed HTML content of the Chrome Release blog page.

    Returns:
    pd.DataFrame: A DataFrame containing structured vulnerability details.
    """
    print('Retrieving Google Chrome Data...')

    ## Get affected version
    versions = get_affected_version(soup)
    
    # Combine the extracted version information into a single string
    windows_mac_versions = ', '.join(versions['Windows/Mac'])  # Joining all Windows/Mac versions
    linux_versions = ', '.join(versions['Linux'])  # Joining all Linux versions
    
    # Format the output in the required format
    output_text = f"[windows: {windows_mac_versions}], [linux: {linux_versions}]"

    # end of affected version

    # Initialize a list to store CVE-related information
    cve_info = []

    # Keywords to look for in the text
    keywords = ['CVE', 'High', 'Medium', 'Low']

    # Find all text elements in the soup that contain any of the keywords
    for element in soup.find_all(text=True):
        text = element.strip()
        if any(keyword in text for keyword in keywords):
            cve_info.append(text)

    # Convert the list to a DataFrame for processing
    df_cve_info = pd.DataFrame(cve_info, columns=['CVE Information'])

    # Process the DataFrame to extract structured details
    formatted_df = detect_and_format_dataframe(df_cve_info, cve_info)

    formatted_df['Affected Version'] = output_text

    return formatted_df

def detect_and_format_dataframe(df, cve_info_list):
    """
    Detects the format of the CVE data and extracts details accordingly.

    Parameters:
    df (pd.DataFrame): DataFrame containing raw CVE information.
    cve_info_list (list): List of CVE information strings.

    Returns:
    pd.DataFrame: DataFrame with structured CVE details.
    """
    # List of possible severity levels
    severity_levels = ['High', 'Medium', 'Low']

    def is_original_format(df):
        """
        Checks if the DataFrame alternates between severity and CVE information.

        Returns:
        bool: True if the DataFrame is in the expected original format.
        """
        for i in range(0, len(df) - 1, 2):
            severity = df.iloc[i, 0].strip()
            cve_info = df.iloc[i + 1, 0].strip()
            if severity not in severity_levels:
                return False
            if not re.match(r'CVE-\d{4}-\d+', cve_info):
                return False
        return True

    # Check if the DataFrame is in the original format
    if is_original_format(df):
        # Initialize lists to store extracted data
        severities = []
        cve_numbers = []
        descriptions = []

        # Extract data in pairs (Severity and CVE Information)
        for i in range(0, len(df) - 1, 2):
            severity = df.iloc[i, 0].strip()
            cve_info = df.iloc[i + 1, 0].strip()

            # Use regex to extract CVE number and description
            match = re.match(r'(CVE-\d{4}-\d+):\s*(.*)', cve_info)
            if match:
                cve_number = match.group(1)
                description = match.group(2)

                # Append to the lists
                severities.append(severity)
                cve_numbers.append(cve_number)
                descriptions.append(description)

        # Create a structured DataFrame
        formatted_df = pd.DataFrame({
            'Severity': severities,
            'CVE Number': cve_numbers,
            'Description': descriptions
        })

        return formatted_df

    else:
        print("The DataFrame is not in the original format.")
        print('Attempting to parse alternate format.')

        # Initialize lists to store extracted data
        severities = []
        cve_numbers = []
        descriptions = []

        # Regex pattern to extract severity, CVE number, and description
        pattern = r'\] (\w+) (CVE-\d{4}-\d+): (.*)\. Reported'

        # Loop through the list and extract data using the regex pattern
        for item in cve_info_list:
            match = re.search(pattern, item)
            if match:
                severities.append(match.group(1))
                cve_numbers.append(match.group(2))
                descriptions.append(match.group(3))

        # Create a structured DataFrame
        df_formatted = pd.DataFrame({
            'CVE Number': cve_numbers,
            'CVSS Base Score': 'Not Available',
            'CVSS Rating': severities,
            'Affected Product': 'Google Chrome',
            'Affected Version': 'Please input',
            'Description': descriptions,
        })

        return df_formatted



def get_affected_version(soup):
    # Find all divs with class "post-content post-original"
    divs = soup.find_all("div", {"class": "post-content post-original"})
    
    # Initialize a list to store the text content
    div_texts = []

    # Iterate over each div and extract all text
    for div in divs:
        # Extract all text from the div and append to the list
        text = div.get_text(separator='\n', strip=True)
        div_texts.append(text)

    # Join all the divs' text into one string
    full_text = "\n".join(div_texts)
    
    # Extract versions from the combined text
    versions = extract_versions(full_text)
    
    return versions

def extract_versions(text):
    # Regex to match the version patterns for Windows/Mac/Linux
    version_pattern = r'(\d+\.\d+\.\d+\.\d+)(/\.\d+)?(?:\s*\((Linux|Windows|Mac)\))?'
    
    # Extract matches
    matches = re.findall(version_pattern, text)
    
    # Prepare results for each OS
    versions = {'Windows/Mac': [], 'Linux': []}
    
    for match in matches:
        version, subversion, os_type = match
        
        # Normalize output based on OS and available subversion
        if os_type == "Linux" or (subversion == '' and 'Linux' in text):
            versions['Linux'].append(f'{version}{subversion}')
        else:
            versions['Windows/Mac'].append(f'{version}{subversion}' if subversion else version)
    
    return versions

