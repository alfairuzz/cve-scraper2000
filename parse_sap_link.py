from requests_html import HTMLSession
from bs4 import BeautifulSoup
import pandas as pd
import re


def get_sap_details(soup):
    # # Find all paragraphs with the class 'gb-paragraph'
    information = soup.find_all('table')

    table = information[0]

    # Extract the headers (this part is customized for the desired columns)
    headers = ["Note#", "Title", "CVE Number", "Priority", "CVSS"]

    # Extract the rows
    rows = []
    for row in table.find_all('tr')[1:]:  # Skip the header row
        cols = row.find_all('td')
        
        # Extract Note# from the first column
        note_number = cols[0].get_text(strip=True)
        
        # Extract the content from the second column (Title, CVEs)
        title_text = cols[1].get_text(separator=" ").strip()

        # Find all CVEs in the title
        cve_matches = re.findall(r'CVE-\d{4}-\d{4,}', title_text)
        
        # If multiple CVEs are found, duplicate the row for each CVE
        if cve_matches:
            for cve_number in cve_matches:
                # Use "Multiple CVEs" in the title if more than one CVE exists
                title_for_row = title_text
                
                # Extract Priority from the third column
                priority = cols[2].get_text(strip=True)
                
                # Extract CVSS from the fourth column
                cvss_score = cols[3].get_text(strip=True)
                
                # Append the row data in the desired order
                rows.append([note_number, title_for_row, cve_number, priority, cvss_score])
        else:
            # Handle cases where no CVE is found
            cve_number = 'N/A'
            
            # Extract Priority from the third column
            priority = cols[2].get_text(strip=True)
            
            # Extract CVSS from the fourth column
            cvss_score = cols[3].get_text(strip=True)
            
            # Append the row data in the desired order
            rows.append([note_number, title_text, cve_number, priority, cvss_score])

    # Create a DataFrame
    df = pd.DataFrame(rows, columns=headers)

    # Display the DataFrame
    print(df)

    # Function to extract Product and Version from the Title
    def extract_product_and_version(title):
        # Regular expression to capture Product and Versions information
        # This will handle various dash formats (colon, dash, em dash, en dash, etc.)
        product_match = re.search(r'(?i)Product\s*[-:–—]\s*(.*?)(?=,?\s*(Versions?|Version\s*[:-–—]))', title)
        
        # Modify the version regex to account for inconsistent spacing between "Version" and "-"
        version_match = re.search(r'(?i)Version[s]?\s*[-:–—]?\s*(.*)', title)
        
        # Look for the pattern with "[Multiple CVEs]" or just "]"
        if "[Multiple CVEs]" in title:
        # Capture everything after "[Multiple CVEs]" and before "Product", accounting for newlines and extra spaces
            impact_match = re.search(r'\[Multiple CVEs\]\s*(.*?)\s*Product', title, re.IGNORECASE | re.DOTALL)
            
        else:
            # Capture everything after the closing "]" and before "Product", accounting for newlines and extra spaces
            impact_match = re.search(r'\]\s*(.*?)\s*Product', title, re.IGNORECASE | re.DOTALL)
        
        # Extract product and version information if found, else set to 'N/A'
        product = product_match.group(1).strip() if product_match else 'N/A'
        versions = version_match.group(1).strip() if version_match else 'N/A'
        
        
        # Extract the impact information if found, else set to 'N/A'
        impact = impact_match.group(1).strip() if impact_match else 'N/A'
        
        # Remove any remaining "CVEs" text within the impact if found
        impact = re.sub(r'CVEs\s*-.*', '', impact).strip()
        
        return product, versions, impact

    # Apply the function to the Title column to extract Product and Versions
    df['Product'], df['Versions'], df['Impact'] = zip(*df['Title'].apply(extract_product_and_version))

    # Use a regular expression to remove "– " and keep the rest
    df['Versions'] = df['Versions'].replace(r'–\s*', '', regex=True)
    df['Impact'] = df['Impact'].str.strip()

    return df


# # URL of the webpage to scrape
# url = 'https://support.sap.com/en/my-support/knowledge-base/security-notes-news/september-2024.html'

# # Start the HTML session and get the webpage content
# s = HTMLSession()
# r = s.get(url)

# # Render the dynamic content (JavaScript)
# r.html.render(sleep=1)

# # Save the rendered HTML content
# html_content = r.html.html

# # Parse the HTML with BeautifulSoup
# soup = BeautifulSoup(html_content, 'html.parser')

# # Find all paragraphs with the class 'gb-paragraph'
# information = soup.find_all('table')

# table = information[0]

# # Extract the headers (this part is customized for the desired columns)
# headers = ["Note#", "Title", "CVE Number", "Priority", "CVSS"]

# # Extract the rows
# rows = []
# for row in table.find_all('tr')[1:]:  # Skip the header row
#     cols = row.find_all('td')
    
#     # Extract Note# from the first column
#     note_number = cols[0].get_text(strip=True)
    
#     # Extract the content from the second column (Title, CVEs)
#     title_text = cols[1].get_text(separator=" ").strip()

#     # Find all CVEs in the title
#     cve_matches = re.findall(r'CVE-\d{4}-\d{4,}', title_text)
    
#     # If multiple CVEs are found, duplicate the row for each CVE
#     if cve_matches:
#         for cve_number in cve_matches:
#             # Use "Multiple CVEs" in the title if more than one CVE exists
#             title_for_row = title_text
            
#             # Extract Priority from the third column
#             priority = cols[2].get_text(strip=True)
            
#             # Extract CVSS from the fourth column
#             cvss_score = cols[3].get_text(strip=True)
            
#             # Append the row data in the desired order
#             rows.append([note_number, title_for_row, cve_number, priority, cvss_score])
#     else:
#         # Handle cases where no CVE is found
#         cve_number = 'N/A'
        
#         # Extract Priority from the third column
#         priority = cols[2].get_text(strip=True)
        
#         # Extract CVSS from the fourth column
#         cvss_score = cols[3].get_text(strip=True)
        
#         # Append the row data in the desired order
#         rows.append([note_number, title_text, cve_number, priority, cvss_score])

# # Create a DataFrame
# df = pd.DataFrame(rows, columns=headers)

# # Display the DataFrame
# print(df)

# # Function to extract Product and Version from the Title
# def extract_product_and_version(title):
#     # Regular expression to capture Product and Versions information
#     product_match = re.search(r'(?i)Product\s*[:-]\s*(.*?)(?=,?\s*(Versions?|Version\s*[:-]))', title)
    
#     # Modify the version regex to account for inconsistent spacing between "Version" and "-"
#     version_match = re.search(r'(?i)Version[s]?\s*-?\s*(.*)', title)
    
#     # Extract product and version information if found, else set to 'N/A'
#     product = product_match.group(1).strip() if product_match else 'N/A'
#     versions = version_match.group(1).strip() if version_match else 'N/A'
    
#     return product, versions

# # Apply the function to the Title column to extract Product and Versions
# df['Product'], df['Versions'] = zip(*df['Title'].apply(extract_product_and_version))

# # Use a regular expression to remove "– " and keep the rest
# #df['Product'] = df['Product'].replace(r'–\s*', '', regex=True)

# # Save the DataFrame to Excel
# df.to_excel(r"./data/SAP Updates/sap_security_table.xlsx", index=False)
